<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Blogs</title>
<link rel="stylesheet" href="../css/styles_blog_pages.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div class="container">
	<div class="header">
		<div class="nav-buttons left">
			<a href="../blogs.html" class="home-btn">
				<img src="../images/back_arrow.ico" alt="Back" class="back-icon">
			</a>
		</div>
		<h1>Fully Sharded Data Parallel (FSDP)</h1>
	</div>
	<br>
	<div class="image-container" align="center">
		<img src="../images/blogs/fsdp_header.png" alt="Header FSDP", class="responsive-img", style="width: 500px;">
	</div>
    <br>
	<div class="blog-content">
		<h2>Overview</h2>

		<p> In this blog I attempt to explain FSDP, highlighting its significance in optimizing memory usage and scaling training across multiple GPUs.</p>

		<p>I then explain how FSDP works, detailing the process of parameter sharding, gradient synchronization, and checkpointing. A dedicated section compares FSDP1 vs FSDP2, outlining the limitations of the original implementation and the improvements introduced in FSDP2.</p>
        <p>Finally, I demonstrate how to implement FSDP2 using PyTorch, providing practical guidance for integrating it with LoRA during fine-tuning.</p>

        <h2>Introduction</h2>
		<p>Training AI models at a large scale is a challenging task that requires a lot of compute power and resources. It also comes with considerable engineering complexity to handle the training of these very large models.</p>

		<p>Fully Sharded Data Parallel (FSDP) makes it easier for us to efficiently train very large neural network models that would otherwise exceed the memory capacity of a single GPU. FSDP achieves this by sharding (splitting) model parameters, optimizer states, and gradients across multiple GPUs, rather than replicating the entire model on each device as in traditional data parallelism.</p>

		<p>This approach hence brings us the following benefits:</p>
		<ul>
		<li>Enabling Training of Larger Models</li>
		<li>Improves Memory Efficency</li>
		<li>Optimizes Computational Resources</li>
		<li>Flexible and Scalable</li>
		<li>Reduces Redundancy (Don't need full model copies on each device)</li>
		</ul>
		<h2>How FSDP works ?</h2>

		<p>When training with FSDP, the GPU memory footprint is smaller than when training with <a href="https://docs.pytorch.org/tutorials/intermediate/ddp_tutorial.html">DDP</a> across all workers. This makes the training of some very large models feasible by allowing larger models or batch sizes to fit on device. This comes with the cost of increased communication volume. The communication overhead is reduced by internal optimizations like overlapping communication and computation.</p>

        <div class="image-container" align="center">
                    <img src="../images/blogs/fsdp_overview.png" alt="FSDP Overview", class="responsive-img", style="width: 500px;">
        </div>
        <br>
		<p>At a high level FSDP works as follows:</p>
		<p>In constructor</p>
		<ul>
		<li>Shard model parameters and each rank only keeps its own shard</li>
        </ul>
        <p>In forward path</p>
        <ul>
        <li>Run all_gather to collect all shards from all ranks to recover the full parameter in this FSDP unit</li>
        <li>Run forward computation</li>
        <li>Discard parameter shards it has just collected</li>
		</ul>
		<p>In backward path</p>
		<ul>
		<li>Run all_gather to collect all shards from all ranks to recover the full parameter in this FSDP unit</li>
		<li>Run backward computation</li>
		<li>Run reduce_scatter to sync gradients</li>
		<li>Discard parameters</li>
		</ul>

        <p>An implmentation of FSDP can  be found here: <a href="https://docs.pytorch.org/tutorials/intermediate/FSDP_tutorial.html#how-to-use-fsdp">How to use FSDP</a></p>

        <h2>FSDP1 Vs FSDP2</h2>

        <p>First, we want to understand how FSDP1 and FSDP2 work internally to understand the differences between them. This also helps us understand the limitations of FSDP1 and how FSDP2 solves them.</p>

        <p>Lets visualize this and understand what the problem is....</p>
        <p>Lst's say we have a single layer that contains 3 linear layers and is wrapped using <strong>FSDP1</strong> to be sharded accross 2 GPUs</p>
        <h3>FSDP1</h3>
        <div class="image-container" align="center">
                    <img src="../images/blogs/FSDP1.png" alt="FSDP1", class="responsive-img", style="width: 500px;">
        </div>
        <p>The whole Layer gets flattened into a single FlatParameter, which then gets sharded across ranks. However, this FlatParameter complicates applying different behaviors to individual parameters within the FlatParameter, e.g. parameter freezing, parameter casting, etc., hurting composability, and it complicates the internal implementation, e.g. making state dict logic thousands of lines and requiring additional communications.</p>

        <h3>FSDP2</h3>

        <div class="image-container" align="center">
                    <img src="../images/blogs/FSDP2.png" alt="FSDP2", class="responsive-img", style="width: 500px;">
        </div>
        <p>FSDP2 represents sharded parameters as <b>DTensors</b> sharded on dim-0, allowing for easy manipulation of individual parameters, communication-free sharded state dicts, and a simpler meta-device initialization flow.</p>
        <p>FSDP2 implements an improved memory management system that achieves lower and deterministic GPU memory by avoiding <b>recordStream</b> and does so without any CPU synchronization.</p>

        <h2>Implementing LoRA+FSDP2</h2>
        <p>The following steps outline the implementation of FSDP2 with LoRA for fine-tuning a large language model (LLM). For details on LoRA, please refer to my earlier blog <a href="qlora.html">here</a>.</p>
		<p>Setting up <b>Model and LoRA configurations</b>
        <pre class="compact-code"><code>model = AutoModelForCausalLM.from_pretrained(
	base_model,
	torch_dtype=torch.bfloat16,
	trust_remote_code=True,
	use_cache=False,
)
model.gradient_checkpointing_enable()
# ---- LoRA Configuration ----
lora_config = LoraConfig(
	r=8,
	lora_alpha=16,
	target_modules=["q_proj", "v_proj", "k_proj", "o_proj"],
	lora_dropout=0.05,
	bias="none",
	task_type="CAUSAL_LM",
)
model = get_peft_model(model, lora_config)
model = model.to(torch.bfloat16)
for param in model.parameters():
	param.requires_grad = False

for name, param in model.named_parameters():
	if "lora" in name.lower():
		param.requires_grad = True</code></pre>
		<p>To optimize memory usage, we load the model using the <code>bfloat16</code> data type instead of the default <code>float32</code>. This significantly reduces memory consumption while maintaining numerical stability, especially on hardware that supports <code>bfloat16</code> natively. For a deeper understanding of the differences between <code>float32</code>, <code>float16</code>, and <code>bfloat16</code>, you can refer to <a href="https://www.linkedin.com/pulse/float32-vs-float16-bfloat16-damien-benveniste-av3oc/" target="_blank">this article</a>. Additionally, gradient checkpointing is enabled after loading the model to further optimize memory efficiency. This technique reduces memory usage during backpropagation by storing only a subset of activations and recomputing the rest on the fly.</p>
		<p>To enable parameter-efficient fine-tuning, we configure and apply LoRA (Low-Rank Adaptation) to the model. LoRA allows us to inject trainable low-rank matrices into specific layers (such as <code>"q_proj", "k_proj", "v_proj",</code> and <code>"o_proj"</code>) of the transformer architecture. We use a rank of 8 and an alpha value of 16 for scaling. After applying LoRA using the <code>get_peft_model()</code> function, we convert the model to <code>bfloat16</code> precision for efficient memory usage. We then freeze all base model parameters and selectively unfreeze only the LoRA layers. This setup ensures that only a small subset of parameters is updated during training, drastically reducing memory and compute requirements without compromising performance.</p>
		<pre class="compact-code"><code>world_size = dist.get_world_size()
device_mesh = init_device_mesh("cuda", (world_size,))
fsdp_kwargs = {
	"mp_policy": MixedPrecisionPolicy(
		param_dtype=torch.bfloat16,
		reduce_dtype=torch.bfloat16,
	),
	"offload_policy": OffloadPolicy()
}

from transformers.models.llama.modeling_llama import LlamaDecoderLayer
for module in model.modules():
	if isinstance(module, LlamaDecoderLayer):
		fully_shard(module, mesh=device_mesh, **fsdp_kwargs)
fully_shard(model, mesh=device_mesh, **fsdp_kwargs)</code></pre>
		<p>To enable memory-efficient distributed training, we apply Fully Sharded Data Parallel (FSDP2) using PyTorchâ€™s native APIs. We begin by initializing a device mesh across all available GPUs, which defines how model parameters are partitioned across devices. A MixedPrecisionPolicy is then configured to use bfloat16 for both parameter storage and inter-device communication, enabling faster computation and lower memory consumption. We also include an OffloadPolicy to optionally move parameters or optimizer states to the CPU when necessary. Since FSDP2 requires all model parameters to be in the same data type, we explicitly convert the model to bfloat16 before wrapping it. The sharding is first applied selectively to each LlamaDecoderLayer, providing fine-grained control, and then the entire model is wrapped with fully_shard() to finalize the setup. This allows efficient fine-tuning of large models across multiple GPUs with significantly reduced memory overhead.</p>
        <p>Complete code for LoRA+FSDP2 can be found <a href="https://github.com/Arush04/qlora_tuned_model/blob/main/fsdp2_pytorch.py">here</a>.</p>
		<h2>Summary</h2>
		<p>When fine-tuning large language models like LLaMA-3.1-8B, GPU memory becomes a major bottleneck. This is where FSDP2 (Fully Sharded Data Parallel v2) comes into play. FSDP2 shards the modelâ€™s parameters and optimizer states across multiple GPUs, dramatically reducing per-GPU memory usage while enabling training at scale. In our setup, we use LoRA (Low-Rank Adaptation) to fine-tune the model in a parameter-efficient manner â€” updating only a small fraction of weights (e.g., ~50MB). By freezing the base model and training only the LoRA layers, we drastically cut down the size of gradients and optimizer states.</p>
		<p>Lets say for example we have a 4 GPU cluster, then a 16GB model in bfloat16 would be split across the GPUs with each GPU holding only 4GB of parameters. Even after accounting for communication and gradient synchronization overhead, total memory per GPU stays in the ~6â€“8GB range â€” far below what would be required for full fine-tuning without FSDP (which could exceed 90GB per GPU).</p>
		<p>In summary, FSDP2 + LoRA allows:</p>
		<ul>
		  <li>Fine-tuning of large models with reduced memory overhead</li>
		  <li>Training only LoRA layers while sharding the rest</li>
		  <li>Feasibility of training large models even on modest GPU setups</li>
		</ul>
		</p>This makes FSDP2 a powerful tool for scalable, resource-efficient model fine-tuning.</p>
		<h2>References and useful resources:</h2>
			<ol>
                <li><a href="https://arxiv.org/pdf/2304.11277">PyTorch FSDP Paper</a></li>
				<li><a href="https://docs.pytorch.org/tutorials/intermediate/FSDP_tutorial.html">Getting Started with Fully Sharded Data Parallel(FSDP)</a></li>
				<li><a href="https://www.youtube.com/watch?v=UvRl4ansfCg&t=2257s">Slaying OOMs with PyTorch FSDP and torchao</a></li>
				<li><a href="https://huggingface.co/docs/accelerate/en/concept_guides/fsdp1_vs_fsdp2">FSDP1 vs FSDP2</a></li>
			</ol>
	</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script></body>
</html>
